
// Part 2 and 3 about a really dumb investment strategy
//======================================================


//two test portfolios

val blchip_portfolio = List("GOOG", "AAPL", "MSFT", "IBM", "FB", "AMZN", "BIDU")
val rstate_portfolio = List("PLD", "PSA", "AMT", "AIV", "AVB", "BXP", "CCI",
  "DLR", "EQIX", "EQR", "ESS", "EXR", "FRT", "HCP")


// (1) The function below takes a stock symbol and a year as arguments.
//     It should read the corresponding CSV-file and reads the January 
//     data from the given year. The data should be collected in a list of
//     strings for each line in the CSV-file.

import io.Source
import scala.util._

def get_january_data(symbol: String, year: Int): List[String] = {
  val portfolioFile = symbol + ".csv"
  val bufferedSource = Source.fromFile("./" + portfolioFile)
  val stringList = bufferedSource.getLines.toList
  val yearString = stringList.filter(_.startsWith(year.toString))
  //yearString.foreach(println)
  bufferedSource.close
  yearString
}

//println( get_january_data("GOOG", 2005) )

//def get_contents(name: String) : Option[List[String]] =
// Try(Source.fromFile(name).getLines.toList).getOrElse(Some(None))

// (2) From the output of the get_january_data function, the next function 
//     should extract the first line (if it exists) and the corresponding
//     first trading price in that year with type Option[Double]. If no line 
//     is generated by get_january_data then the result is None; Some if 
//     there is a price.


def get_first_price(symbol: String, year: Int): Option[Double] = {
  val janData = get_january_data(symbol, year)
  //println(janData(0).split(",")(1) )
  //val price = janData(0).split(",")(1)
  Try(Some(janData(0).split(",")(1).toDouble)).getOrElse(None)

}
//println(get_first_price("GOOG", 1980))

// (3) Complete the function below that obtains all first prices
//     for the stock symbols from a portfolio (list of strings) and 
//     for the given range of years. The inner lists are for the
//     stock symbols and the outer list for the years.


def get_prices(portfolio: List[String], years: Range): List[List[Option[Double]]] = {
  val multipleSymbol = for (year <- years;
                            symbol <- portfolio) yield get_first_price(symbol, year)
  multipleSymbol.toList.sliding(portfolio.length, portfolio.length).toList //TODO MUST ABSOLUTELY CHANGE THIS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
}

//println(get_prices(List("GOOG", "AAPL","AMT"), 2010 to 2012))
//==============================================
// Do not change anything below, unless you want 
// to submit the file for the advanced part 3!
//==============================================


// (4) The function below calculates the change factor (delta) between
//     a price in year n and a price in year n + 1. 

def get_delta(price_old: Option[Double], price_new: Option[Double]): Option[Double] = {
  Try(Some((price_new.get - price_old.get) / price_old.get)).getOrElse(None)
}


// (5) The next function calculates all change factors for all prices (from a
//     portfolio). The input to this function are the nested lists created by 
//     get_prices above.

def get_deltas(data: List[List[Option[Double]]]): List[List[Option[Double]]] = {
  val q = for (n <- 0 to data.length - 2;
               m <- 0 to data(0).length - 1
  ) yield get_delta(data(n)(m), data(n + 1)(m))

  q.toList.sliding(data(0).length, data(0).length).toList
}

//println( get_deltas( (get_prices(List("GOOG", "AAPL"), 2004 to 2007)) ) )
// (6) Write a function that given change factors, a starting balance and an index,
//     calculates the yearly yield, i.e. new balance, according to our dumb investment 
//     strategy. Index points to a year in the data list.

def yearly_yield(data: List[List[Option[Double]]], balance: Long, index: Int): Long = {

//  val yearYield = for (n <- 0 to data(index).length - 1
//                       if data(index)(n).isInstanceOf[Some[Double]] ) yield data(index)(n).get

  val yearYield = data(index).flatten
  if(yearYield.length == 0){ balance}
  else {
    val perStock = balance.toDouble / yearYield.length.toDouble
    val profit = (for (delta <- yearYield) yield perStock * delta).sum
//    println(balance)
//    println(profit)
//    println( balance + profit.toLong )
    balance + profit.toLong
  }
}
//println( get_deltas( get_prices(List("GOOG", "AAPL"), 2010 to 2012)) )
// println( yearly_yield( get_deltas( get_prices(List("GOOG", "AAPL"), 2010 to 2012)),100,0) )

// (7) Write a function compound_yield that calculates the overall balance for a 
//     range of years where in each year the yearly profit is compounded to the new 
//     balances and then re-invested into our portfolio. For this use the function and 
//     results generated under (6). The function investment calls compound_yield
//     with the appropriate deltas and the first index.



def compound_yield(data: List[List[Option[Double]]], balance: Long, index: Int) : Long = {

  //val invest = yearly_yield(data, balance,index)
  if(index <= data.length-1 ) {

    val invest = yearly_yield(data, balance,index)
    compound_yield(data, invest, index +1)
  }
  else {
    balance
  }
}

def investment(portfolio: List[String], years: Range, start_balance: Long) : Long = {
  val price = get_prices(portfolio, years)
  val deltas = get_deltas(price)

  //println(price.length)
  //println(deltas.length)

  compound_yield(deltas, start_balance, 0)
}


//Test cases for the two portfolios given above

//println("Real data: " + investment(rstate_portfolio, 1978 to 2018, 100))
//println("Blue data: " + investment(blchip_portfolio, 1978 to 2018, 100))


